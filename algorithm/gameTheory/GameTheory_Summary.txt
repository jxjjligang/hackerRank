1. [Alice and Bob's Silly Game]
   The idea is straightforward - count the [Prime Number] with range of N.
   Use Sieve algorithm to quickly flag [Prime Numbers].
   
2. [bob And Ben]   
   After learn [Sprague-Grundy Theorem], [Nimbers and Mex] from [GeeksforGeeks], I can complete this task.
   https://www.geeksforgeeks.org/combinatorial-game-theory-set-3-grundy-numbersnimbers-and-mex/
   
3. [Game of Stones]
   Easy, use iterative idea, starts from known results and accumulate to the final result.

4. [Mis√®re Nim]
   Read discussion to solve the task.
   (1). If player 1 starts with an xor value of zero, player 1 loses unless the piles are: [1,1], [1,1,1,1], etc.
   (2). If player 1 starts with an xor value other than zero, player 1 wins unless the piles are: [1], [1,1,1], etc.

5. [Nimble Game]
   Read discussion to solve the task.
   (1). The ith square has i squares (0 1 2 .... i-1) before it, so for each coin in current square you actually has i ways to move, so it's like having i stones in a standard nim    
        game. The coins aren't the stones in the Nim's term. The slots before the current square are.
   (2). The number of coins in each square is just a flag, if initially some square has even number of coins, no matter what the first player did, all the changes can be cancel out 
        by putting all rest of the coins in current square (will be an odd number) to the same set of squares the first player put onto.
		
6. [A Chessboard Game]		
   I have figured out all the flow of code, with the help from discussion, I corrected logic for 2 if condition clause and then complete the task. 
   
7. [Chocolate in Box]
   Straightforward, just use the idea of classic Nim Game (remove stones from piles) to find how many moving ways for first player to win.

8. [Powers Game]
   Key points:
   (1). Since both players play optimally and player 2 plays after player 1, therefore player 2
        must be able to make his play works with previous player 1 play - the combination 
        of their step won't affect the final result;
   (2) 17 = 16 + 1 = 32 + 2 = 2^5 + 2^1, for every number player 1 choose find the other one
       that could make the equation still works, then we find the number of series must be times of 8.   
	   
9. [Play on benders]	   
   Key points: 
       (1). Written in C# so as to use its profiler to identify the bottleneck. 
	        A single line change decreame time from 9 seconds to 0 second.
	   
	        Before: IEnumerable<int> nextLocations = paths.Where(p => p[0] == location).Select(p => p[1]);
	        After:  IEnumerable<int> nextLocations = parent2Children[location];
	   (2). Implement a iterative program flow does help me to locate the bottleneck; however the recursive way can't because it calls itself.

10. [Chessboard Game, Again]
    Use [Sprague Grundy Theorem] to solve the problem, first calculate the Grundy Number for every 
	cell in the grid, then calculate the accumulated XOR result of all the input coins, return result 
    based on the XOR result is 0 or not.

11. [Permutation game]
    
	
   