1. [Fibonacci Modified]
   Simple, use iteration to reach the target result; 
   In JavaScript, use BigInt for big number so as not to lose precision.

2. [Stock Maximize]
   My solution is push and pop, memorize the profit make and days, eventually accumulate to the final result.
   Editorial first introduces a naive solution - use 2 level iteration to find the profit that can be made for each day.
             Then, a simpler solution is to run the loop backward and keep track of the maximum stock price so far, time complexity is O(n**2). 
			 This way you can eliminate the inner for loop, time complexity is O(n).   
			 
3. [Abbreviation]	
   It's quite straightforward to construct a recursive solution.
   But hard to implement in a iterative way. But I still be able to implement it correctly on January 6, 2020. Four months before, I can only follow the idea of Editorial to write code. 

4. [Fibonacci Modified]
	Straigthforward to implement.

5. [The Coin Change Problem] 
   My solution is try to memorize each combination detail (the type/number of coin that used), is not easy to implement and will consume memory exponentially.
   My solution only pass 6 cases, can't pass performance cases (take 47 seconds for case #3).
   
   However, the code from [rwan7727] works very fast to pass all cases.
   Also, the editorial gives a classic solution, consume O(n) memory space and O(m*n) time complexity.
   
6. [Lego Blocks]
   Key Points: 
    (1). Starts from the basic case (only 1 row whose width is w)
    (2). Then for n rows (without think unsafe cases), therefore g(n) = f(w)**n;
	(3). Think about every combination of safe(i) and unsafe(i-j), use DN to find all the values for h(1) until h(n-1)
	h[i] = g[i] - Sum of (h[j] * g[i-j]), j is [1, i-1]

7. [Bricks Game]
    Key point: Use [Pre Sum Arr] and [bottom up] idea, previous player is actuallly a different    
           way of showing first player. 
		   
8. [Xor and Sum]
    My solution: When the bits that b shifted is more than a length, then a^b = a + b;
             Based on that, I can deduce the result. 		

9. [The Maximum Subarray]			 
   Kadaneâ€™s Algorithm: implement it to get [Max SubArray]; [Max SubSequence] is simply sum of all non-negative element's value.
   
10.[The Longest Increasing Subsequence]
   The dynamic programming way (iteration way) is easy to understand and implement.
   But, it cant' pass performance test cases because its time complexity is O(n**2).  
   
   However, there is O(n*log(n)) algorithm, refer link: https://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/
   You must have the idea of [multiple active increasing list], and compare their end element with the incoming array element, then we will have 3 cases:
   (1). [incoming array element] < (all of them), a new [active increasing list] should be created.
   (2). [incoming array element] > (all of them), clone [longest active increasing list] as new list, append [incoming array element] to it.
   (3). [incoming array element] is between (all of them), then need find the [biggest end element] among lists whose [end element] is < [incoming array element], 
        clone that list and append [incoming array element], delete [active list] which has the same length as the new list just created.
   Eventually, return the longest [active list] length;		
   To improve performance, save all the [end elements] in a sorted array. 
   
11.[Mandragora Forest]   
   Key point:
   (1). Sort the input array in ascending order;
   (2). Iterate the sorted input, check each element of the array, decide the better way from (eat, battle).
   (3). The decision is based from compare (current health * current element) with (sum of left elements).
   The editorial made a clear discussion about how the logic and strategy was made.
   
   
12.[Knapsack]
   My solution is a little bit longer than the [editorial one], but time combination are both O(n^2).
      (1). Create a distinct array from input and sort the array in ascending order. 
      (2). Iterate every element of sorted array, and multiply them with count++, and save into [combination array]. 
      (3). Nest iterate [combination array], the outer iteration find the min element, then the inner iteration will add min with other elements left in [combination array], and update [combination array].
      Eventually, iterate backwards the [combination array], return the nearest number.

  The editorial solution is way simpler and straightforward, it shows me that the recursive way can start in a forward manner, not necessarily backward. 	  