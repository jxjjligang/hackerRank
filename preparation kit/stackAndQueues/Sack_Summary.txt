Methodology:

Largest Rectangle: 
	2 ways that both use stack, but
	(1). During iteration of height array, push into stack with object {width: 1, value: height}, 
	      when incoming height >= top of stack, increment width by 1 for all existing stack objects and push incoming object;
          otherwise pop stack object until top stack object height >= incoming height, then push incoming object;
    keep updating largest rectangle by width*height when pop occurs and in the end
 
    (2). The idea is the same as the above, 2 points are different:
         #1 push statk the index of height array, when pop occurs, width = (incoming index - [value poped from stack] - 1) OR
		    incoming index value when stack is empty;
		 #2 push height value which is smaller than the minimum value of height array, this helps to pop stack in the end

	
Max Min Riddle:
    Essentially, the same solution for [Largest Rectangle] can be applied to it.
		
	
	Poisonous Plants:
	
	
Technique:
	Balanced Brackets: 
	    Crate stack and check each character:
        	if it is left bracket, then push into stack;
    		if it is right bracket check if there is match left bracket at the top of stack, pop out of stack if found.

	Queues: A Tale of Two Stacks:
	        Create 2 stack: enqueue_statck and dequeue_statck;
			For enqueue operation, push value into enqueue_statck, for dequeue operation, pops all the values from enqueue_statck into dequeue_statck, then pop dequeue_statck;
			For print operation, print dequeue_statck if it has value, else move values from enqueue_statck into dequeue_statck and print the top value of dequeue_statck.