1. Roads and Libraries:
   The key point is how to split cities that connected (directly or indirectly) into graphs;
   Then for each graph, 
               let costLibs = graphLen * c_lib, costRoadAndLibs = c_lib + roadsLength * c_road;
               minCost += Math.min(costLibs, costRoadAndLibs);
			   
2. Find the nearest clone:
   The key point is for each node that has TARGET value, use BFS or DFS to find another node has TARGET value; 			   
       and finally returns the minimum value of them;
   If choose to use BFS, push the queue with object {node: nodeIndex, depth: depth value from top node} will help.

3. BFS: Shortest Reach in a Graph
   Simple: just use BFS to get the depth value from the start node

4. Connected Cell in a Grid:
   Key point: for each cell whose value is 1, use DFS (deep-first-search) to count all the adjacent 1 cells; 
                                             in DFS recursion it will stop when cell value is 0, otherwise will continue and increment [CELL COUNT] variable;
											 
   Cell and its possible adjancent cells:								       
        /*
        0 means current cell, it has 8 possible adjacent cells, each number from 1 to 8 represents a possible position
                    6 7 8
                    5 0 1
                    4 3 2  
        */
        //                      1        2                        3                    4                        5        6                        7                    8
        // let adjacentCells = [key + 1, key + 1 + COLUMN_LENGTH, key + COLUMN_LENGTH, key + COLUMN_LENGTH - 1, key - 1, key - 1 - COLUMN_LENGTH, key - COLUMN_LENGTH, key - COLUMN_LENGTH + 1];
											    