1. Warm-up challenges
   (1). Sock Merchant: simply use [count array] for counting pairs of sock
   (2). Counting Valleys: find the rule for [valley confirmation]
   (3). Jumping on the Clouds: a greedy way, simple
   (4). Repeated String: Still simple enough to finish with minutes

2. Arrays 
   (1). 2D Array - DS: simple, understand row, column index
   (2). Arrays: Left Rotation: use Array.prototype.slice function
   (3). New Year Chaos: iterate each person in queue,
		#1 If current person sticker > 2 + (Original person sticker) => Too choas
		#2 Count how many times the current person is bribed: count sub array 
		(starts from a place before the current person original place, to a place 
		before the current person index
   (4). Minimum Swaps 2: the Editorial use dfs, I don;t get it now. (Sep 11, 2020) 
   (5). Array Manipulation: I still remember the skills to pass performance tests.

3. Dictionaries and Hashmaps
   (1). Ransom Note: Simple
   (2). Two Strings: Simple
   (3). Sherlock and Anagrams:
        #1. Use 2-level nested loop to find all possible subStrings, and compute signature for each subString,
		    save signature to a Map object, whose key-value is signature-count (how many times it repeats)
		#2. Iterator map created in step 1 and get the final result
   (4). [Triplet]: 2 ways to solve it; I prefer the idea from Editorial
   (5). [Frequency Queries]: 
        #1. Create a Map object (key -> Frequency) will pass most test cases except fail one performance case
		#2. Create another Map (Frequency -> Set of keys) helps to pass performance case

4. Sorting
   (1). Bubble Sort: Simple
   (2). Mark and tops: Simple, essentially is a greedy algorithm, each greedy step contributes to the final correct solution.
   (3). Comparator: Simple
   (4). Fraudulent Activity Notifications
	    #1. Use [counting array]
		#2. Use [priority queue], I still has bug to fix.

   (5). 

   (1). 
   (2). 
   (3). 
   (4). 
   (5). 


   (1). 
   (2). 
   (3). 
   (4). 
   (5). 


   (1). 
   (2). 
   (3). 
   (4). 
   (5). 


   (1). 
   (2). 
   (3). 
   (4). 
   (5). 
