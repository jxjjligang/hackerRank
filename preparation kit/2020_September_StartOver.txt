1. Warm-up challenges
   (1). Sock Merchant: simply use [count array] for counting pairs of sock
   (2). Counting Valleys: find the rule for [valley confirmation]
   (3). Jumping on the Clouds: a greedy way, simple
   (4). Repeated String: Still simple enough to finish with minutes

2. Arrays 
   (1). 2D Array - DS: simple, understand row, column index
   (2). Arrays: Left Rotation: use Array.prototype.slice function
   (3). New Year Chaos: iterate each person in queue,
		#1 If current person sticker > 2 + (Original person sticker) => Too choas
		#2 Count how many times the current person is bribed: count sub array 
		(starts from a place before the current person original place, to a place 
		before the current person index
   (4). Minimum Swaps 2: the Editorial use dfs, I don;t get it now. (Sep 11, 2020) 
   (5). Array Manipulation: I still remember the skills to pass performance tests.

3. Dictionaries and Hashmaps
   (1). Ransom Note: Simple
   (2). Two Strings: Simple
   (3). Sherlock and Anagrams:
        #1. Use 2-level nested loop to find all possible subStrings, and compute signature for each subString,
		    save signature to a Map object, whose key-value is signature-count (how many times it repeats)
		#2. Iterator map created in step 1 and get the final result
   (4). [Triplet]: 2 ways to solve it; I prefer the idea from Editorial
   (5). [Frequency Queries]: 
        #1. Create a Map object (key -> Frequency) will pass most test cases except fail one performance case
		#2. Create another Map (Frequency -> Set of keys) helps to pass performance case

4. Sorting
   (1). Bubble Sort: simple
   (2). Mark and tops: simple, essentially is a greedy algorithm, each greedy step contributes to the final correct solution.
   (3). Comparator: simple
   (4). Fraudulent Activity Notifications
	    #1. Use [counting array]
		#2. Use [priority queue], I still has bug to fix.

   (5). Merge Sort Counting Inversions:
        #1. Divide and conquer: halve array into left, right part and call msRecursive (recursive merge sort) on them;
		#2. Compare first item of left, right [half array], if left item > 
			right item, then swaps += left.length; (means all itmes of left half array should be swapped against first item of left half array)
			
5. String
   (1). Making Anagrams: simple
   (2). Alternating Characters: simple
   (3). Sherlock and the Valid String: simple, just need to be clear 3    
        cases that return 'YES'
   (4). Special String Again
		Below is my idea, still O(n*n*n)
		#1. Use 2-level loop to find all subStrings, return [if is special, count of different chars from the first char]
		#2. Break out of the inner loop when arr[1] > 1 (from step 1)
		
		The idea from Editorial is very good, is O(n*n)
   (5). Common Child: 
        #1. In a recursive way, there might be [maximum call stack size exceeded].
		#2. In a iterative way.


   (1). 
   (2). 
   (3). 
   (4). 
   (5). 


   (1). 
   (2). 
   (3). 
   (4). 
   (5). 


   (1). 
   (2). 
   (3). 
   (4). 
   (5). 
